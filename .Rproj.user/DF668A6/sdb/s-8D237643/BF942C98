{
    "collab_server" : "",
    "contents" : "summer_deer_data1=read.csv('summer_main_modeldata_new10April2017.csv')  # read data file into R\n\nsummer_deer_data1$altid=factor(summer_deer_data1$altid) # convert catagorical variable to a vector of factor variables\nsummer_deer_data1$veg_class=factor(summer_deer_data1$veg_class)\n\nlibrary(lme4) #load lme4 package\n\nsummer_deer_data1$stand_dist_to_water=(summer_deer_data1$dist_to_water-mean(summer_deer_data1$dist_to_water))/sd(summer_deer_data1$dist_to_water)\nsummer_deer_data1$stand_cos_aspect=(summer_deer_data1$cos_aspect-mean(summer_deer_data1$cos_aspect))/sd(summer_deer_data1$cos_aspect)\nsummer_deer_data1$stand_sin_aspect=(summer_deer_data1$sin_aspect-mean(summer_deer_data1$sin_aspect))/sd(summer_deer_data1$sin_aspect)\nsummer_deer_data1$stand_elevation=(summer_deer_data1$elevation-mean(summer_deer_data1$elevation))/sd(summer_deer_data1$elevation)\nsummer_deer_data1$stand_slope=(summer_deer_data1$slope-mean(summer_deer_data1$slope))/sd(summer_deer_data1$slope)\n\n####addative model\nsummer_pequop_model=glmer(used~stand_dist_to_water+stand_cos_aspect+stand_sin_aspect+stand_elevation+stand_slope+veg_class+(1|altid),family=\"binomial\",data=summer_deer_data1,nAGQ = 1, na.action=\"na.fail\") # generalized linear mixed effect \n\n####Interactions global \nsummer_pequop_model=glmer(used~stand_dist_to_water+(stand_dist_to_water*stand_elevation)\n                          +(stand_dist_to_water*stand_slope)+(stand_elevation*stand_slope)\n                          +stand_cos_aspect+stand_sin_aspect+stand_elevation+stand_slope\n                          +veg_class+(1|altid),family=\"binomial\",data=summer_deer_data1,nAGQ = 1, na.action=\"na.fail\") # generalized linear mixed effect \n\n####Top Model from dredge 448\nsummer_pequop_model=glmer(used~stand_dist_to_water+(stand_dist_to_water*stand_slope)+(stand_elevation*stand_slope)\n                          +stand_cos_aspect+stand_sin_aspect+stand_elevation+stand_slope\n                          +veg_class+(1|altid),family=\"binomial\",data=summer_deer_data1,nAGQ = 1, na.action=\"na.fail\") # generalized linear mixed effect\n\nmodel_summary <- summary(summer_pequop_model)\nmodel_summary\n\n\n\n\nlibrary(MuMIn)\n\nsummer_dred<- dredge(summer_pequop_model, trace = TRUE, rank = \"AICc\", REML = FALSE)\nsummer_dred\n\nwrite.csv(model_summary$coefficients, file= \"top_summer_main_result19April2017.csv\")\nwrite.csv(summer_dred, file= \"summer_main_dredge_result_10April2017.csv\")\n\n\n\n###################################\n#################### CROSS VALIDATION CODE\nlibrary(ROCR)\nlibrary(rms)\nlibrary(lme4)\n\nn.folds <- 9\nsummer_deer_data1$altid\nuniquedeer <- as.character(unique(summer_deer_data1$altid))\nfolds_df <- data.frame(\n  deer = uniquedeer,\n  fold = c(rep(1:n.folds,each=5),1,2)\n)\nfolds_df\nfoldVector <- folds_df$fold[match(as.character(summer_deer_data1$altid),folds_df$deer)]\n\ncounter = 1\nCVprediction <- numeric(nrow(summer_deer_data1))\nCVobserved <- numeric(nrow(summer_deer_data1))\nrealprediction <- numeric(nrow(summer_deer_data1))\nrealdata <- numeric(nrow(summer_deer_data1))\n\ncounter=1\ni=1\n\n#test <- numeric(nrow(summer_deer_data1))\nfor(i in 1:n.folds){\n  model <- glmer(used~stand_dist_to_water+(stand_dist_to_water*stand_slope)+(stand_elevation*stand_slope)\n                 +stand_cos_aspect+stand_sin_aspect+stand_elevation+stand_slope\n                 +veg_class+(1|altid),family=\"binomial\",data=summer_deer_data1,nAGQ = 1, na.action=\"na.fail\") # generalized linear mixed effect\n  predict_CV  <- plogis(predict(model,newdata=summer_deer_data1[which(foldVector==i),],allow.new.levels = TRUE)) \n  predict_real  <-  plogis(predict(summer_pequop_model,newdata=summer_deer_data1[which(foldVector==i),],allow.new.levels = TRUE))\n  REAL <- summer_deer_data1$used[which(foldVector==i)]\n  for(j in 1:length(which(foldVector==i))){\n    CVprediction[counter] <- predict_CV[j]\n    CVobserved[counter] <-  REAL[j]      \n    realprediction[counter] <- predict_real[j]   \n    realdata[counter] <- REAL[j]         \n    counter = counter + 1  \n  }\n}\n\nCV_RMSE = sqrt(mean((CVobserved-CVprediction)^2))       # root mean squared error for holdout samples in 10-fold cross-validation ...\nreal_RMSE = sqrt(mean((CVobserved-realprediction)^2))  # root mean squared error for residuals from final model\n\n# print RMSE statistics\nCV_RMSE \n## [1] 0.4273769\nreal_RMSE   \n## [1] 0.4273769\npar(mfrow=c(2,1))\npred <- prediction(CVprediction,CVobserved)     # for holdout samples in cross-validation\nperf <- performance(pred,\"tpr\",\"fpr\")\nauc <- performance(pred,\"auc\")\nplot(perf, main=\"GLMER Cross validation\")\ntext(.9,.1,paste(\"AUC = \",round(auc@y.values[[1]],2),sep=\"\"))\n\npred <- prediction(realprediction,CVobserved)     # for final model\nperf <- performance(pred,\"tpr\",\"fpr\")\nauc <- performance(pred,\"auc\")\nplot(perf, main=\"GLMER\")\ntext(.9,.1,paste(\"AUC = \",round(auc@y.values[[1]],2),sep=\"\"))\n\n\n### display confusion matrix and kappa for a single threshold\n\ncutoff = 0.5\n\ntrueLabels <- CVobserved\npredLabels <- ifelse(CVprediction>=cutoff,1,0)    \ntot <- length(CVobserved)\ntp <- length(which((trueLabels==1)&(predLabels==1)))  \ntn <- length(which((trueLabels==0)&(predLabels==0)))\nfp <- length(which((trueLabels==0)&(predLabels==1)))\nfn <- length(which((trueLabels==1)&(predLabels==0)))\npr_agree <- (tp+tn)/tot    # overall agreement, or accuracy\npr_agree_rand <- ((tp+fn)/tot)*((tp+fp)/tot)+((fn+tn)/tot)*((fp+tn)/tot)\nkappa <- (pr_agree-pr_agree_rand)/(1-pr_agree_rand)\nkappa\n## [1] 0.4414166\nmatrix(c(tp,fp,fn,tn),nrow=2,ncol=2)\n##     [,1] [,2]\n## [1,] 7745 2420\n## [2,] 3258 6907\nsensitivity <- tp/(tp+fn)\nspecificity <- tn/(tn+fp)\ntoterror <- (fn+fp)/tot\nsensitivity\n## [1] 0.7619282\nspecificity\n## [1] 0.6794884\ntoterror\n## [1] 0.2792917\nCVprediction[which(CVprediction==1)] <- 0.9999\nCVprediction[which(CVprediction==0)] <- 0.0001\nrealprediction[which(realprediction==1)] <- 0.9999\nrealprediction[which(realprediction==0)] <- 0.0001\n\n\n\nrealdata = CVobserved\nfit_deviance_CV <- mean(-2*(dbinom(CVobserved,1,CVprediction,log=T)-dbinom(realdata,1,realdata,log=T)))\nfit_deviance_real <- mean(-2*(dbinom(CVobserved,1,realprediction,log=T)-dbinom(realdata,1,realdata,log=T)))\nnull_deviance <- mean(-2*(dbinom(CVobserved,1,mean(CVobserved),log=T)-dbinom(realdata,1,realdata,log=T)))\ndeviance_explained_CV <- (null_deviance-fit_deviance_CV)/null_deviance   # based on holdout samples\ndeviance_explained_real <- (null_deviance-fit_deviance_real)/null_deviance   # based on full model...\n\ndeviance_explained_CV\n## [1] 0.2184701\ndeviance_explained_real\n## [1] 0.2184701\n\n\n",
    "created" : 1507312046591.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "389881627",
    "id" : "BF942C98",
    "lastKnownWriteTime" : 1497391932,
    "last_content_update" : 1497391932,
    "path" : "E:/Dropbox/Mule Deer/Methods paper/CODE_deprecated/GLMER_summer.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}